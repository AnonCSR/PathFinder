#pragma once

#include <iostream>

#include "antlr4-runtime.h"

#include "misc/logger.h"
#include "query/query_context.h"
#include "query/parser/grammar/sparql/autogenerated/SparqlLexer.h"
#include "query/parser/grammar/sparql/autogenerated/SparqlParser.h"
#include "query/parser/grammar/sparql/query_visitor.h"
#include "query/parser/op/op.h"
#include "query/rewriter/sparql/op/check_scoped_blank_nodes.h"
#include "query/rewriter/sparql/op/check_var_names.h"
#include "query/rewriter/sparql/op/replace_unscoped_variables.h"
#include "query/rewriter/sparql/op/change_join_to_sequence.h"
#include "query/rewriter/sparql/op/rewrite_filter_subqueries.h"
#include "query/rewriter/sparql/op/rewrite_rule_visitor.h"
#include "query/rewriter/sparql/op/rewrite_rules/distribute_join_union.h"
#include "query/rewriter/sparql/op/rewrite_rules/distribute_optionals_to_union.h"
#include "query/rewriter/sparql/op/rewrite_rules/distribute_minus_to_union.h"
#include "query/rewriter/sparql/op/rewrite_rules/flatten_union.h"
#include "query/rewriter/sparql/op/rewrite_rules/distribute_filter_over_union.h"
#include "query/rewriter/sparql/op/rewrite_rules/decompress_and_filter.h"
#include "query/rewriter/sparql/op/rewrite_rules/flatten_filter.h"
#include "query/rewriter/sparql/op/rewrite_rules/push_filter_into.h"
#include "query/rewriter/sparql/op/rewrite_rules/expr_into_normal_form.h"
#include "query/rewriter/sparql/op/rewrite_rules/simplify_bound.h"
#include "query/rewriter/sparql/op/rewrite_rules/remove_empty_filter.h"
#include "query/rewriter/sparql/op/rewrite_rules/literal_removal.h"
#include "query/rewriter/sparql/op/rewrite_rules/not_exists_to_minus.h"
#include "query/rewriter/sparql/op/rewrite_rules/exists_to_semi_join.h"

namespace SPARQL {

class QueryParser {
public:
    static std::unique_ptr<Op> get_query_plan(
        const std::string& query,
        antlr4::ANTLRErrorListener* error_listener = nullptr)
    {
        antlr4::ANTLRInputStream  input(query);
        SparqlLexer               lexer(&input);
        antlr4::CommonTokenStream tokens(&lexer);
        SparqlParser              parser(&tokens);

        parser.getInterpreter<antlr4::atn::ParserATNSimulator>()->setPredictionMode(
            antlr4::atn::PredictionMode::SLL
        );

        if (error_listener != nullptr) {
            parser.removeErrorListeners();
            parser.addErrorListener(error_listener);
        }
        SparqlParser::QueryContext* tree = parser.query();

        QueryVisitor::GlobalInfo global_info;
        QueryVisitor visitor(global_info);
        visitor.visitQuery(tree);

        auto res = std::move(visitor.current_op);

        logger.ostream(Category::LogicalPlan, 1) << " Initial logical plan:\n" << *res;

        CheckVarNames check_var_names;
        res->accept_visitor(check_var_names);

        CheckScopedBlankNodes check_scoped_blank_nodes;
        res->accept_visitor(check_scoped_blank_nodes);

        ReplaceUnscopedVariables replace_unscoped_variables;
        res->accept_visitor(replace_unscoped_variables);
        logger.ostream(Category::LogicalPlan, 1) << " Replacing unscoped variables:\n" << *res;

        use_all_rewrite_rules(res);
        logger.ostream(Category::LogicalPlan, 1) << " Applying all rewrite rules:\n" << *res;

        ChangeJoinToSequence join_to_sequence_visitor;
        res->accept_visitor(join_to_sequence_visitor);
        logger.ostream(Category::LogicalPlan, 1) << " Changing join to sequence:\n" << *res;


        RewriteFilterSubqueries rewrite_filter_subqueries;
        res->accept_visitor(rewrite_filter_subqueries);
        logger.ostream(Category::LogicalPlan, 1) << " Rewriting filter subqueries:\n" << *res;

        logger.ostream(Category::LogicalPlan) << " Final logical plan:\n" << *res;

        return res;
    }

    static void use_all_rewrite_rules(std::unique_ptr<Op>& op) {
// #define sparql_query_parser_rewrite_debug

#ifdef sparql_query_parser_rewrite_debug
        std::cout << "Starting to do rewrite rules" << std::endl;
#endif
        RewriteRuleVisitor rule_rewriter;
        rule_rewriter.add_rule<DistributeJoinUnion                      >();
        rule_rewriter.add_rule<DistributeOptionalsToUnion               >();
        rule_rewriter.add_rule<DistributeMinusToUnion                   >();
        rule_rewriter.add_rule<FlattenUnion                             >();
        rule_rewriter.add_rule<ExprIntoNormalForm                       >();
        rule_rewriter.add_rule<DecompressAndFilter                      >();
        rule_rewriter.add_rule<FlattenFilter                            >();
        rule_rewriter.add_rule<LiteralRemoval                           >();
        rule_rewriter.add_rule<SimplifyBound                            >();
        rule_rewriter.add_rule<RemoveEmptyFilter                        >();
        rule_rewriter.add_rule<PushFilterInto<OpJoin>                   >();
        rule_rewriter.add_rule<PushFilterInto<OpOptional>               >();
        rule_rewriter.add_rule<PushFilterInto<OpMinus>                  >();
        rule_rewriter.add_rule<DistributeFilterOverUnion                >();
        rule_rewriter.add_rule<NotExistsToMinus                         >();
        rule_rewriter.add_rule<ExistsToSemiJoin                         >();
        // TESTS: INFO(STRING). op->print_to_ostream(std::cout);
        rule_rewriter.begin_visit(op);

#ifdef sparql_query_parser_rewrite_debug
        std::cout << "After rewriting the rules:" << std::endl;
        std::cout << *op << std::endl;
#endif
    }
};

} // namespace SPARQL
